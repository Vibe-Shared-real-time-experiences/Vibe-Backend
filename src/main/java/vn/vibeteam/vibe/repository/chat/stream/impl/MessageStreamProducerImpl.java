package vn.vibeteam.vibe.repository.chat.stream.impl;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.connection.RedisStreamCommands;
import org.springframework.data.redis.connection.stream.StreamRecords;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;
import tools.jackson.databind.ObjectMapper;
import vn.vibeteam.vibe.dto.event.ChannelMessageCreatedEvent;
import vn.vibeteam.vibe.repository.chat.stream.MessageStreamProducer;

import java.util.HashMap;
import java.util.Map;

@Component
@RequiredArgsConstructor
@Slf4j
public class MessageStreamProducerImpl implements MessageStreamProducer {
    private final StringRedisTemplate redisTemplate;
    private final ObjectMapper objectMapper;
    private static final String STREAM_KEY = "vibe:stream:messages";

    @Override
    public void sendToStream(ChannelMessageCreatedEvent channelMessage) {
        try {
            // 1. Serialize msg to JSON String
            String messageJson = objectMapper.writeValueAsString(channelMessage);

            // 2. Create record map
            Map<String, String> record = new HashMap<>();
            record.put("payload", messageJson);

            // 3. Add to Redis Stream
            // The id will be auto-generated by Redis
            redisTemplate.opsForStream().add(
                    StreamRecords.newRecord()
                                 .ofMap(record)
                                 .withStreamKey(STREAM_KEY),
                    RedisStreamCommands.XAddOptions
                            .maxlen(100000)
                            .approximateTrimming(true)
            );

            log.debug("Pushed message {} to stream", channelMessage.getChannelId());

        } catch (Exception e) {
            log.error("Failed to push to stream", e);
            // TODO: Store to a dead-letter queue or persis directly to DB
        }
    }
}
